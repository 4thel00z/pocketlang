/*
 *  Copyright (c) 2021 Thakee Nathees
 *  Licensed under: MIT License
 */

 /** A template header to emulate C++ template and every occurence of
  * M__NAME will be replaced by the name of the buffer and M__TYPE will be
  * replaced by the element type of the buffer (by a pre compile script) */

void M_CONC(M__NAME_L,BufferInit)(M_CONC(M__NAME,Buffer)* self) {
  self->data = NULL;
  self->count = 0;
  self->capacity = 0;
}

void M_CONC(M__NAME_L,BufferClear)(M_CONC(M__NAME,Buffer)* self, MSVM* vm) {
  vmRealloc(vm, self->data, self->capacity * sizeof(M__TYPE), 0);
  self->data = NULL;
  self->count = 0;
  self->capacity = 0;
}

void M_CONC(M__NAME_L,BufferFill)(M_CONC(M__NAME,Buffer)* self, MSVM* vm, M__TYPE data, int count) {
  
  if (self->capacity < self->count + count) {
    int capacity = utilPowerOf2Ceil((int)self->count + count);
    if (capacity < MIN_CAPACITY) capacity = MIN_CAPACITY;
    self->data = (M__TYPE*)vmRealloc(vm, self->data,
      self->capacity * sizeof(M__TYPE), capacity * sizeof(M__TYPE));
    self->capacity = capacity;
  }

  for (int i = 0; i < count; i++) {
    self->data[self->count++] = data;
  }
}

void M_CONC(M__NAME_L,BufferWrite)(M_CONC(M__NAME,Buffer)* self, MSVM* vm, M__TYPE data) {
  M_CONC(M__NAME_L,BufferFill)(self, vm, data, 1);
}
